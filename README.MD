# Шестой поток Python

## Модуль №1. Управление созданием экземпляров класса

### Занятие m01_01 (06.07.2022)

> Рассмотрели создание метаклассов. Абстрактные базовые классы. Рассмотрены методы `exec`, `eval` и
> пример `ast`

Вызов встроенного класса `type()` может использоваться в качестве динамического эквивалента объявления класса. Ниже
приведен пример определения класса с вызовом `type()`:

```python
def method(self):
    return 1


MyClass = type('MyClass', (object,), {'method': method})
```

Это эквивалентно явному определению класса с ключевым словом `class`:

```python
class MyClass:
    def method(self):
        return 1
```

Каждый класс, который явно создается таким образом, имеет метакласс `type`. Такое поведение по умолчанию можно изменить,
добавив именованный аргумент `metaclass`:

```python
class ClassWithAMetaclass(metaclass=type):
    pass
```

Значение, предоставляемое в качестве аргумента `metaclass`, — это, как правило, еще один объект класса, но может быть
любым другим вызываемым объектом, который принимает те же аргументы, что и класс `type`, и возвращает другой объект
класса. Сигнатура вызова такова: `type(name, bases, namespace)`. Значение аргументов выглядит следующим образом:

- `name` — имя класса, которое будет храниться в атрибуте `__name__`;
- `bases` — список родительских классов, которые станут атрибутом `__base__` и будут использоваться для построения ПРМ
  вновь созданного класса;
- `namespace` — пространство имен (отображение) с определениями для тела клас- са, который станет атрибутом `__dict__`.

Метаклассы — это своего рода метод `__new__()`, но на более высоком уровне определения класса. Несмотря на то что вместо
метаклассов можно добавить функции, которые явно вызывают `type()`, обычно для этого используется другой класс,
наследующий от `type`. Общий шаблон для метакласса выглядит следующим образом:

```python
class Metaclass(type):
    def __new__(mcs, name, bases, namespace):
        return super().__new__(mcs, name, bases, namespace)

    @classmethod
    def __prepare__(mcs, name, bases, **kwargs):
        return super().__prepare__(name, bases, **kwargs)

    def __init__(cls, name, bases, namespace, **kwargs):
        super().__init__(name, bases, namespace)

    def __call__(cls, *args, **kwargs):
        return super().__call__(*args, **kwargs)
```

Аргументы `name, bases, namespace` имеют такое же значение, как и в `type()`, но все эти четыре метода могут иметь
различные цели.

- Метод `__new__(mcs, name, bases, namespace)` отвечает за фактическое создание объекта класса, как и у обычных классов.
  Первый аргумент является объектом метакласса. В предыдущем примере это был бы просто Metaclass. Обратите внимание,
  что `mcs` — общепринятое имя для данного аргумента.
- Метод `__prepare__(mcs, name, bases, **kwargs)` создает пустой объект про- странства имен. По умолчанию возвращает
  пустой `dict`, но может возвращать и любой другой тип отображения. Обратите внимание: он не принимает `namespace` в
  качестве аргумента, поскольку до вызова пространство имен еще не существует.
- Метод `__init__(cls, name, bases, namespace, **kwargs)` не особо популярен в реализации метакласса, но имеет тот же
  смысл, что и в обычных классах. Он может выполнять дополнительную инициализацию объекта класса, как только тот будет
  создан с помощью `__new__()`. Первый позиционный аргумент теперь называется `cls` и обозначает уже созданный объект
  класса (экземпляр метакласса), а не объект метакласса. В момент вызова `__init__()` класс уже был создан, и поэтому
  данный метод не так полезен, как `__new__()`. Реализация такого метода очень похожа на использование декораторов
  класса, но основное отличие состоит в том, что `__init__()` будет вызываться для каждого подкласса, а вот декораторы
  класса для подклассов не вызываются.
- Метод `__call__(cls, *arg, **kwargs)` вызывается, когда вызывается экземпляр метакласса. Последний является объектом
  класса, он вызывается при создании новых экземпляров класса. Метод позволяет переопределить способ создания и
  инициализации экземпляров класса.
-

Методы `exec`, `eval` и `ast`

- `exec(object, global, locals)` — позволяет динамически выполнять код Python. Элемент `object` должен быть строкой или
  объектом кода (см. функцию `compile()`), представляющим один оператор или последовательность нескольких.
  Аргументы `global` и `local` — это глобальные и локальные пространства имен для исполняемого кода, которые не являются
  обязательными. Если они не указаны, то код выполняется в текущем пространстве. Если указаны, то `global` должен быть
  словарем, а `local` может быть любым объектом отображения, он всегда возвращает `None`.

- `eval(expression, global, locals)` — используется для вычисления данного выражения и возвращает его значение. Похоже
  на `exec()`, но `expression` — это всего одно выражение Python, а не последовательность операторов. Возвращает
  значение вычисленного выражения.

- `compile(source, filename, mode)` — компилирует источник в объект кода или AST. Исходный код предоставляется в
  качестве строкового значения в аргументе `source`. `filename` — это файл, из которого читается код. Если связанного
  файла нет (например, потому что он был создан динамически), обычно используется значение `<string>`.

Режим

- `exec` (последовательность операторов),
- `eval` (одно выражение) или `single` (один интерактивный оператор, например, в интерактивной сессии Python).

### Занятие m01_02  (08.07.2022)

- `ex01` - `ex02` Правильный подход к декорированию
- `ex02` - `ex05`, `my_logger` - Принципы логирования
- `ex06` - Ведение логирования к функции: `level` - это уровень, `name` — это имя регистратора, а message — это
  сообщение журнала. Если имя и сообщение не указаны,
  по умолчанию они соответствуют модулю и имени функции.
- `ex07` - модификация примера `ex06`
- `ex08` - Написание декораторов, которые добавляют аргументы обернутым функциям
- `ex09` - Определение декораторов как классов
- `ex10` - `ex12` - Пример упрощения класса `Person` с помощью макроподстановки

## Модуль №2. Приемы объектно-ориентированного программирования

### Занятие m02_01 (13.07.2022)

Рассмотрели **SOLID**

### Занятие m02_02 (15.07.2022)

Рассмотрели основные паттерны проектирования

## Модуль №3. Python Deployment

### Занятие m03_01 (20.07.2022) Pipenv, Poetry

Создание UI приложения

Tkinter (від англ. Tk interface) — багатоплатформна графічна бібліотека інтерфейсів на основі засобів Tk (широко
розповсюджена у світі GNU/Linux та інших UNIX подібних систем, портована в тому числі і на Microsoft Windows, Apple Mac
OS), поширювана з відкритими вихідними текстами, написана Стіном Лумхольтом (Steen Lumholt) і Гвідо ван Россумом.
Входить у стандартну бібліотеку Python.

Команда создания десктоп приложения для `app_pipenv`:

```shell
pipenv run pyinstaller -F --icon=alisa.ico --noconsole main.py
```

[Игра сапер на Tkinter](https://www.youtube.com/watch?v=I4yl0VbXpA8&list=PLQAt0m1f9OHtfXxDph-MJvYCLaOvildGQ)

[Poetry](https://python-poetry.org/docs/basic-usage/) - это инструмент для управления зависимостями в Python проектах (
аналог встроенного pip).

[Poetry видео](https://www.youtube.com/watch?v=KOC0Gbo_0HY)

Облачный сервис [Replit](https://replit.com)

[Docker Desktop](https://www.docker.com/products/docker-desktop/)

### Занятие m03_02 (22.07.2022) Docker

Скачать с DockerHUB образ и запустить контейнер с БД MongoDB последней версии. Флаг `-d` используем, чтобы не заходить
внутрь контейнера и запускаем его в режиме `demon`

```shell
docker run -d mongo
```
Если хотим запустить контейнер и сразу зайти в него, то выполняем команду

```shell
docker run -it mongo
```

Если контейнер уже работает с флагом `-d` то зайти в него можно командой, главное указать его `id hash`

```shell
docker exec -it <hash>
```

Посмотреть на запущенные контейнеры можно командой. Если добавить флаг `-a` увидим еще и не запущенные контейнеры

```shell
docker ps -a
```

Остановить выполнение контейнера можно командой `stop`, после надо указать или имя контейнера, или его `hash` (можно
ввести первые цифры `hash`, главное чтобы докер однозначно понял, что надо остановить)

```shell
docker stop <name|hash>
```

Повторный запуск команда `start`

```shell
docker start <name|hash>
```

Удаление контейнера

```shell
docker rm <name|hash>
```

Чтобы контейнер был нам "полезен" необходимо пробросить порты наружу. Слева это наш порт `27017:27017`, который будет
виден на компьютере для нашей программы. Справа порт который использует контейнер внутри себя. Левый можем указывать при
запуске любой, главное, чтобы он был свободен в системе.

```shell
docker run -p 27017:27017 -d mongo
```

Для того чтобы вывести сохранение данных БД снаружи контейнера можно использовать `voluemes`. Это позволяет хранить
данные не внутри контейнера, а локально на диске в папке `e/dbstorage`.

```shell
docker run -p 27017:27017 -v e/dbstorage:/data/db -d mongo
```

Создать образ из **Dockerfile**. Точка это путь, где находится файл **Dockerfile**

```shell
docker build . -t nickname/name-image
```

Запустить сборку из `docker-compose.yml` файла внутри папки с файлом

```shell
docker-compose up -d
```