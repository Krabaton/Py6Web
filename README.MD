# Шестой поток Python

# Оглавление

1. [Модуль №1. Управление созданием экземпляров класса](#module01)
2. [Модуль №2. Приемы объектно-ориентированного программирования](#module02)
3. [Модуль №3. Python Deployment](#module03)
4. [Модуль №4. Многопоточность в Python](#module04)
5. [Модуль №5. Процессы в Python](#module05)
6. [Модуль №6. Асинхронное программирование](#module06)

## Модуль №1. Управление созданием экземпляров класса <a name="module01"></a>

### Занятие m01_01 (06.07.2022)

> Рассмотрели создание метаклассов. Абстрактные базовые классы. Рассмотрены методы `exec`, `eval` и
> пример `ast`

Вызов встроенного класса `type()` может использоваться в качестве динамического эквивалента объявления класса. Ниже
приведен пример определения класса с вызовом `type()`:

```python
def method(self):
    return 1


MyClass = type('MyClass', (object,), {'method': method})
```

Это эквивалентно явному определению класса с ключевым словом `class`:

```python
class MyClass:
    def method(self):
        return 1
```

Каждый класс, который явно создается таким образом, имеет метакласс `type`. Такое поведение по умолчанию можно изменить,
добавив именованный аргумент `metaclass`:

```python
class ClassWithAMetaclass(metaclass=type):
    pass
```

Значение, предоставляемое в качестве аргумента `metaclass`, — это, как правило, еще один объект класса, но может быть
любым другим вызываемым объектом, который принимает те же аргументы, что и класс `type`, и возвращает другой объект
класса. Сигнатура вызова такова: `type(name, bases, namespace)`. Значение аргументов выглядит следующим образом:

- `name` — имя класса, которое будет храниться в атрибуте `__name__`;
- `bases` — список родительских классов, которые станут атрибутом `__base__` и будут использоваться для построения ПРМ
  вновь созданного класса;
- `namespace` — пространство имен (отображение) с определениями для тела клас- са, который станет атрибутом `__dict__`.

Метаклассы — это своего рода метод `__new__()`, но на более высоком уровне определения класса. Несмотря на то что вместо
метаклассов можно добавить функции, которые явно вызывают `type()`, обычно для этого используется другой класс,
наследующий от `type`. Общий шаблон для метакласса выглядит следующим образом:

```python
class Metaclass(type):
    def __new__(mcs, name, bases, namespace):
        return super().__new__(mcs, name, bases, namespace)

    @classmethod
    def __prepare__(mcs, name, bases, **kwargs):
        return super().__prepare__(name, bases, **kwargs)

    def __init__(cls, name, bases, namespace, **kwargs):
        super().__init__(name, bases, namespace)

    def __call__(cls, *args, **kwargs):
        return super().__call__(*args, **kwargs)
```

Аргументы `name, bases, namespace` имеют такое же значение, как и в `type()`, но все эти четыре метода могут иметь
различные цели.

- Метод `__new__(mcs, name, bases, namespace)` отвечает за фактическое создание объекта класса, как и у обычных классов.
  Первый аргумент является объектом метакласса. В предыдущем примере это был бы просто Metaclass. Обратите внимание,
  что `mcs` — общепринятое имя для данного аргумента.
- Метод `__prepare__(mcs, name, bases, **kwargs)` создает пустой объект про- странства имен. По умолчанию возвращает
  пустой `dict`, но может возвращать и любой другой тип отображения. Обратите внимание: он не принимает `namespace` в
  качестве аргумента, поскольку до вызова пространство имен еще не существует.
- Метод `__init__(cls, name, bases, namespace, **kwargs)` не особо популярен в реализации метакласса, но имеет тот же
  смысл, что и в обычных классах. Он может выполнять дополнительную инициализацию объекта класса, как только тот будет
  создан с помощью `__new__()`. Первый позиционный аргумент теперь называется `cls` и обозначает уже созданный объект
  класса (экземпляр метакласса), а не объект метакласса. В момент вызова `__init__()` класс уже был создан, и поэтому
  данный метод не так полезен, как `__new__()`. Реализация такого метода очень похожа на использование декораторов
  класса, но основное отличие состоит в том, что `__init__()` будет вызываться для каждого подкласса, а вот декораторы
  класса для подклассов не вызываются.
- Метод `__call__(cls, *arg, **kwargs)` вызывается, когда вызывается экземпляр метакласса. Последний является объектом
  класса, он вызывается при создании новых экземпляров класса. Метод позволяет переопределить способ создания и
  инициализации экземпляров класса.
-

Методы `exec`, `eval` и `ast`

- `exec(object, global, locals)` — позволяет динамически выполнять код Python. Элемент `object` должен быть строкой или
  объектом кода (см. функцию `compile()`), представляющим один оператор или последовательность нескольких.
  Аргументы `global` и `local` — это глобальные и локальные пространства имен для исполняемого кода, которые не являются
  обязательными. Если они не указаны, то код выполняется в текущем пространстве. Если указаны, то `global` должен быть
  словарем, а `local` может быть любым объектом отображения, он всегда возвращает `None`.

- `eval(expression, global, locals)` — используется для вычисления данного выражения и возвращает его значение. Похоже
  на `exec()`, но `expression` — это всего одно выражение Python, а не последовательность операторов. Возвращает
  значение вычисленного выражения.

- `compile(source, filename, mode)` — компилирует источник в объект кода или AST. Исходный код предоставляется в
  качестве строкового значения в аргументе `source`. `filename` — это файл, из которого читается код. Если связанного
  файла нет (например, потому что он был создан динамически), обычно используется значение `<string>`.

Режим

- `exec` (последовательность операторов),
- `eval` (одно выражение) или `single` (один интерактивный оператор, например, в интерактивной сессии Python).

### Занятие m01_02  (08.07.2022)

- `ex01` - `ex02` Правильный подход к декорированию
- `ex02` - `ex05`, `my_logger` - Принципы логирования
- `ex06` - Ведение логирования к функции: `level` - это уровень, `name` — это имя регистратора, а message — это
  сообщение журнала. Если имя и сообщение не указаны,
  по умолчанию они соответствуют модулю и имени функции.
- `ex07` - модификация примера `ex06`
- `ex08` - Написание декораторов, которые добавляют аргументы обернутым функциям
- `ex09` - Определение декораторов как классов
- `ex10` - `ex12` - Пример упрощения класса `Person` с помощью макроподстановки

## Модуль №2. Приемы объектно-ориентированного программирования  <a name="module02"></a>

### Занятие m02_01 (13.07.2022)

Рассмотрели **SOLID**

### Занятие m02_02 (15.07.2022)

Рассмотрели основные паттерны проектирования

## Модуль №3. Python Deployment <a name="module03"></a>

### Занятие m03_01 (20.07.2022) Pipenv, Poetry

Создание UI приложения

Tkinter (від англ. Tk interface) — багатоплатформна графічна бібліотека інтерфейсів на основі засобів Tk (широко
розповсюджена у світі GNU/Linux та інших UNIX подібних систем, портована в тому числі і на Microsoft Windows, Apple Mac
OS), поширювана з відкритими вихідними текстами, написана Стіном Лумхольтом (Steen Lumholt) і Гвідо ван Россумом.
Входить у стандартну бібліотеку Python.

Команда создания десктоп приложения для `app_pipenv`:

```shell
pipenv run pyinstaller -F --icon=alisa.ico --noconsole main.py
```

[Игра сапер на Tkinter](https://www.youtube.com/watch?v=I4yl0VbXpA8&list=PLQAt0m1f9OHtfXxDph-MJvYCLaOvildGQ)

[Poetry](https://python-poetry.org/docs/basic-usage/) - это инструмент для управления зависимостями в Python проектах (
аналог встроенного pip).

[Poetry видео](https://www.youtube.com/watch?v=KOC0Gbo_0HY)

Облачный сервис [Replit](https://replit.com)

[Docker Desktop](https://www.docker.com/products/docker-desktop/)

### Занятие m03_02 (22.07.2022) Docker

Скачать с DockerHUB образ и запустить контейнер с БД MongoDB последней версии. Флаг `-d` используем, чтобы не заходить
внутрь контейнера и запускаем его в режиме `demon`

```shell
docker run -d mongo
```

Если хотим запустить контейнер и сразу зайти в него, то выполняем команду

```shell
docker run -it mongo
```

Если контейнер уже работает с флагом `-d` то зайти в него можно командой, главное указать его `id hash`

```shell
docker exec -it <hash>
```

Посмотреть на запущенные контейнеры можно командой. Если добавить флаг `-a` увидим еще и не запущенные контейнеры

```shell
docker ps -a
```

Остановить выполнение контейнера можно командой `stop`, после надо указать или имя контейнера, или его `hash` (можно
ввести первые цифры `hash`, главное чтобы докер однозначно понял, что надо остановить)

```shell
docker stop <name|hash>
```

Повторный запуск команда `start`

```shell
docker start <name|hash>
```

Удаление контейнера

```shell
docker rm <name|hash>
```

Чтобы контейнер был нам "полезен" необходимо пробросить порты наружу. Слева это наш порт `27017:27017`, который будет
виден на компьютере для нашей программы. Справа порт который использует контейнер внутри себя. Левый можем указывать при
запуске любой, главное, чтобы он был свободен в системе.

```shell
docker run -p 27017:27017 -d mongo
```

Для того чтобы вывести сохранение данных БД снаружи контейнера можно использовать `voluemes`. Это позволяет хранить
данные не внутри контейнера, а локально на диске в папке `e/dbstorage`.

```shell
docker run -p 27017:27017 -v e/dbstorage:/data/db -d mongo
```

Создать образ из **Dockerfile**. Точка это путь, где находится файл **Dockerfile**

```shell
docker build . -t nickname/name-image
```

Запустить сборку из `docker-compose.yml` файла внутри папки с файлом

```shell
docker-compose up -d
```

## Модуль №4. Многопоточность в Python <a name="module04"></a>

### Занятие m04_01 (27.07.2022)

План урока в названии файлов.

Рассмотрели:

- Создание потоков в Python. `Thread`, `Timer` (01-04)
- Контроль доступа к ресурсам. `Rlock` (05)
- Синхронизация потоков. `Event`, `Condition`, `Semaphore`, `Barrier` (06-11)

### Занятие m04_02 (29.07.2022)

**Приложение** `Task runner`

С помощью потоков собираем (конкатенируем) файлы `js` в один файл `main.js`

**Приложение** `exchangeRate`
Рассмотрели последовательный подход правильного **HTTP** запроса.

2. Вариант реализации через `Queue` - `main_thread_final.py`
3. Вариант реализации через `ThreadPoolExecutor` - `app.py`

Статья [Использование ThreadPoolExecutor в Python 3](https://www.digitalocean.com/community/tutorials/how-to-use-threadpoolexecutor-in-python-3-ru)

## Модуль №5. Процессы в Python <a name="module05"></a>

### Занятие m05_01 (04.08.2022)

### Занятие m05_02 (05.08.2022)

Очень хорошая статья про использование `Pipe` с
процессами [Multiprocessing Pipe in Python](https://superfastpython.com/multiprocessing-pipe-in-python/)

Статья про использование логирования внутри
процессов [Multiprocessing Logging in Python](https://superfastpython.com/multiprocessing-logging-in-python/)

## Модуль №6. Асинхронное программирование <a name="module06"></a>

### Занятие m06_01 (10.08.2022)

### Занятие m06_02 (12.08.2022)

[RuntimeError: Event Loop is Closed asyncio Fix](https://pythonalgos.com/runtimeerror-event-loop-is-closed-asyncio-fix/)

[Асинхронный python без головной боли (часть 1)](https://habr.com/ru/post/667630/)

[Группы асинхронных задач в Python 3.11](https://habr.com/ru/company/otus/blog/681560/)

## Модуль №7. Основы Web <a name="module07"></a>

### Занятие m07_01 (17.08.2022)

#### Как устроен интернет

##### Основные понятия

**Хостинг** — услуга по предоставлению вычислительных мощностей для размещения информации на сервере, постоянно
находящемся
в сети. Хостингом также называется услуга по размещению оборудования клиента на территории провайдера с обеспечением
подключения его к каналам связи с высокой пропускной способностью. Обычно хостинг входит в пакет по обслуживанию сайта и
подразумевает как минимум услугу размещения файлов сайта на сервере, на котором запущено ПО, необходимое для обработки
запросов к этим файлам (веб-сервер). Как правило, в обслуживание уже входит предоставление места для почтовой
корреспонденции, баз данных, DNS, файлового хранилища на специально выделенном файл-сервере и т.п., а также поддержка
функционирования соответствующих сервисов.

**Сервер DNS** — программно-аппаратный комплекс, обеспечивающий трансляцию доменных имен в сетевые адреса (IP-адреса).

![dns](pictures/dns.png)

**Координатор** — уполномоченное юридическое лицо, осуществляющее управление доменами `.ua`.

**Доменное имя** — символьное обозначение, предназначенное для сетевой адресации, в которой используется система
доменных
имен.

**Стоп-лист** — перечень символьных обозначений, регистрация которых в качестве доменных имен недоступна.

**Регистратор** — юридическое лицо, аккредитованное Координатором для регистрации доменных имен в доменах `.ua`

##### Общие сведения

Сервер и браузер общаются, посылая друг другу запросы по особому протоколу – HTTP (RFC-2616). Соединение может
инициировать только браузер. Он посылает серверу запрос — показать такой-то файл.

![http](pictures/http.png)

**HTTP** является синхронным протоколом. Это значит, что клиент послал запрос серверу и пока ждет от него ответ,
следующие
запросы послать не может. Также следует отметить, что **HTTP** — протокол без состояния. Т.е. сервер не сохраняет
информацию
о пользователе между запросами. Для сохранения состояния пользователя в системе используется механизм **cookie** или
сессий.

**Запрос происходит в несколько этапов**:

- *DNS-запрос* — поиск ближайшего DNS-сервера, чтобы преобразовать URI (например, `google.com`) в его числовое
  представление — IP-адрес (`74.125.87.99`, прим. — получено посредством команды `ping`). Это адрес и будет реальным
  адресом сайта в Интернет.
- *соединение* — установка соединения с сервером по полученному IP-адресу;
- *отправка данных*;
- *ожидание ответа* — в этот момент ждем пока пакеты данных дойдут до сервера, он их обработает и ответ вернется назад;
- *получение данных*.

Если какой-то элемент веб страницы размещен на другом хосте, для запроса этого элемента устанавливается новое
соединение, начиная с DNS-запроса.

**Пакеты данных в запросах и ответах между клиентом и сервером содержат HTTP-заголовки. Рассмотрим пример заголовков
запроса:**

```http request
GET /other-19 HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; ru; rv:1.9.1.5) Gecko/20091102 Firefox/3.5.5 (.NET CLR 3.5.30729)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: ru,en-us;q=0.7,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: windows-1251,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
```

В первой строке передается информация о методе передачи данных (в данном случае `GET`), затем идет информация о том на
какой ресурс они передаются, который необходимо вернуть `/other-19`, и в конце версия протокола `HTTP/1.1`. На следующее
строке передается информация о хосте, на который передается запрос. Далее в параметре `User-Agent` клиент передает
информацию о браузере. Затем в параметрах `Accept`, `Accept-Language`, `Accept-Encoding`, `Accept-Charset` передается
информация о кодировке, с которой работает браузер, язык по умолчанию для браузера и метод сжатия информации. В конце,
в параметре `Connection`, следует сообщение серверу, что надо открыть постоянное соединение, а в параметре `Keep-Alive`
указываем на сколько (в секундах) мы открываем соединение с сервером.

В свою очередь сервер может отправить ответ со следующими заголовками:

```http request
HTTP/1.1 200 Ok
Server: nginx
Date: Mon, 29 Sep 2014 12:04:19 GMT
Content-Type: text/html; charset=UTF-8
Connection: close
Cache-Control: no-cache,no-store,max-age=0,must-revalidate
Expires: Mon, 29 Sep 2014 12:04:19 GMT
Last-Modified: Mon, 29 Sep 2014 12:04:19 GMT
Content-Encoding: gzip
``` 

**Ответ сервера состоит из следующих настроек**:

1. В первой строке сервер отдает информацию о версии `HTTP` протокола, статус и описание ответа (все используемые
   статусы
   ответов сервера приведены
   в [здесь](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP)
   .
2. Параметр `Server` говорит о типе сервера.
3. Параметр `Content-Type` – типа отдаваемого содержимого.
4. Параметры `Cache-Control`, `Expires`, `Last-Modified` – отвечают за кэширование ответа сервера.

**Коды состояния ответов сервера**

Часть первой строки ответа сервера при запросах по протоколу `HTTP`. Он представляет собой целое число из трёх
десятичных
цифр. Первая цифра указывает на класс состояния. За кодом ответа обычно следует отделённая пробелом поясняющая фраза на
английском языке, которая разъясняет человеку причину именно такого ответа. Посмотреть, что они значат
можно [здесь](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP)
.

#### HTML

##### Структура документа

**HTML** расшифровывается HyperText Markup Language (в переводе означает Язык Разметки ГиперТекста).

**HTML** - документ по сути есть обычный текстовой файл, который содержит нормально читаемый текст и специальные команды
разметки (tags или теги), заключенные в угловые скобки `<` и `>`. Теги языка HTML задают правила, по которым браузер
выводит документ на экран: размещение текста в окне, представление графических объектов (рисунков и картинок), а также
вывод звуковых, видео клипов и т. д. HTML тэги обычно используются в паре, например: `<b></b>`. Первый тэг называется
начальным тэгом, а второй конечным тэгом.

Текст находящийся между начальным и конечным тэгом подвергается "разметке". Например `<b>Привет</b>` будет отображено
браузером как **Привет** (слово 'Привет' написанное жирным шрифтом).

Следует иметь в виду, что не все теги совместимы с браузерами. Если браузер не понимает тег, то он его просто
пропускает.

Простейший документ HTML - страница это следующая структура:

```html
<!DOCTYPE html >
<html>
<head>
    <title>
        Название
    </title>
</head>
<body>
Текст страницы
</body>
</html>
```

Файл: index.html

Все **HTML5** документы должны начинаться с объявления `DOCTYPE`.

Предыдущие версии HTML имели несколько типов `DOCTYPE`. **HTML5** имеет только один:

```html
<!DOCTYPE html>
```

Данное объявление переводит все браузеры в нормальный режим. Браузеры не поддерживающие HTML5 в данном режиме будут
интерпретировать старые теги и игнорировать новые, которые они не поддерживают.

Тег `<html>` является контейнером, который заключает в себе всё содержимое веб-страницы, включая теги `<head>`
и `<body>`.

Тег `<head>` предназначен для хранения других элементов, цель которых — помочь браузеру в работе с данными. Также внутри
контейнера `<head>` находятся метатеги, которые используются для хранения информации, предназначенной для браузеров и
поисковых систем. Например, механизмы поисковых систем обращаются к метатегам для получения описания сайта, ключевых
слов и других данных.

Элементы, располагающиеся в секции head не отображаются явно на странице и используются для служебных функций.
В секции head могут располагаться скрипты, инструкции об оформлении страницы и различная мета информация о данном **
HTML**
документе.

Метаданные - это информация о данных находящихся в **HTML** документе. Пример метаданных: кодировка страницы, краткое
описание содержимого, ключевые слова, имя автора, дата последней модификации.

Метаданные не отображаются явно на странице, но используются браузерами и поисковыми системами.

В **HTML** метаданные **HTML** документов определяются с помощью тэга `<meta>`. Тэг `<meta>` всегда должен располагаться
в секции `head`.

Для того чтобы указать браузеру пользователя, какая кодировка используется на данной странице необходимо использовать
атрибут `charset` тэга `meta` например так `<meta charset="UTF-8">`.

Если явно не указать кодировку браузер при отображении страницы будет определять ее автоматически. Если кодировка при
этом будет определена неверно пользователь увидит страницу, содержащую бессмысленные символы, поэтому кодировка
обязательно должна указываться к каждому **HTML** документу.

Любой HTML документ имеет название, заключенное между тегами `<title>` и `</titIe>`. По названию документа HTML браузеры
могут найти информацию, поэтому место для названия всегда определено - оно находится вверху экрана и отдельно от
содержимого документа. Максимальная длина названия - 40 символов. Пустой заголовок, не содержащий ни одного символа,
включая пробел, не допустим. Также запрещено включать в код два и более элемента `<title>`, он должен быть только один.

Элемент `title`:

- Определяет заголовок окна браузера;
- Используется как заголовок страницы в результатах выдачи поисковых систем;
- Используется как заголовок страницы при добавлении сайта в избранное.

Тег `<body>` предназначен для хранения содержания веб-страницы, отображаемого в окне браузера. Информацию, которую
следует выводить в документе, следует располагать именно внутри контейнера `<body>`. К такой информации относится текст,
изображения, таблицы, списки и др. элементы HTML элементом называется комбинация начального тэга, конечного тэга и
содержимого. Пример HTML элемента:

```html
<p> Это абзац. </p>
```

Большинство элементов могут быть вложены друг в друга (т.е. в содержимом одного элементе может
располагаться другой элемент).

HTML не чувствителен к регистру это значит, что тэг `<b>` будет интерпретироваться браузером так же как и тэг `<B>`.

Несмотря на то, что HTML не настаивает на строгом синтаксисе рекомендую заранее выработать определенные правила
написания кода (например если Вы пишете тэги в нижней раскладке, то делайте так всегда).

HTML элементы могут иметь атрибуты. Атрибуты задаются в начальном тэге элементов и состоят из имени и значения, например
в атрибуте `href="https://goit.ua/"` `href` является именем, а `https://goit.ua/` значением.

##### Текстовые абзацы

Изучим основные теги для логической разметки текста. Использовать их можно только внутри тега `<body>`.
Начнём с простейшего тега `<p>`, с помощью которого создаются абзацы. По умолчанию абзацы начинаются с новой строки и
имеют вертикальные отступы, которыми можно управлять с помощью стилей.

```html
<p> Я текстовый абзац </p>
```

Для выделения текста в HTML документах могут быть использованы следующие теги: с помощью тега `<b>`, `</b>` можно
установить
жирный шрифт, тег `<i>`, `</i>` устанавливает наклонный шрифт, но лучше для оформления всегда использовать таблицы
стилей CSS.

Допускается также использование в тексте верхних и нижних индексов соответственно с помощью тегов `<sup>`, `</sup>`
и `<sub>`, `</sub>`.

С помощью HTML тэга `<pre>` Вы можете отобразить предформатированный текст. Все что находится внутри тэга `<pre>` будет
отображено точно так как написано. Браузер не будет удалять идущие подряд пробелы и символы перевода строки.

Установка цветов в HTML документе производится с использованием таблицы стилей **CSS**.

Выбор цвета можно производить разными способами: например заданием имени или определением **RGB** номера выбранного
цвета.
Поддерживаются следующие имена цветов: `AQUA, BLACK, BLUE, FUCHSIA, GRAY, GREEN, LIME, MAROON, NAVY, OLIVE, PURPLE, RED,
SILVER, TEAL, WHITE, YELLOW`.

Номер цвета RGB задается тремя двухзначными шестнадцатеричными числами, причем каждое число из интервала `00 — FF` и
определяет интенсивность соответствующего цвета. Например, номер цвета `#FF0000` соответствует красному цвету, так как
имеет максимальную интенсивность для красного, а зеленый и голубой имеют значения, равные нулю. Соответственно, номер
`#00FF00` кодирует зеленый цвет и номер `#0000FF` - голубой.

В HTML5 появился новый тег `<mark>`, который обозначает выделенный текст. Иногда при работе с объёмными текстами мы
используем маркер, чтобы выделять ключевые слова, идеи или что-то другое, на что стоит обратить внимание. Такое же
назначение и у тега `<mark>`. В современных браузерах текст внутри `<mark>` подсвечивается жёлтым фоном.

##### Заголовки и подзаголовки

Для создания структуры больших текстов обычно используются заголовки. В текстовых редакторах есть возможность выделить
часть текста, найти пункт «Заголовок» нужного уровня в меню, и применить его.

Прежде чем остаться на странице и приступить к ее прочтению пользователи обычно бегло пробегают глазами по ее
содержимому проверяя содержит ли она интересующую их информацию. Обычно заголовки это первое (и часто единственное) на
что они обращают внимание, поэтому неправильное использование заголовков может привести к потере посетителей.
В первую очередь заголовки должны кратко и точно описывать содержимое которое они озаглавливают. Наиболее важная
информация страницы должна располагаться под заголовками большего размера, а наименее важная под заголовками меньшего
размера.

В языке HTML для выделения заголовков предусмотрено целое семейство тегов: от `<h1>` до `<h6>`. Тег `<h1>` обозначает
самый важный заголовок (заголовок верхнего уровня), а тег `<h6>` обозначает подзаголовок самого нижнего уровня.
На практике редко встречаются тексты, в которых встречаются подзаголовки ниже третьего уровня. Поэтому самыми часто
используемыми тегами заголовков являются: `<h1>`, `<h2>` и `<h3>`.

Стоит отметить, что поисковые системы придают особое значение заголовкам, поэтому необходимо учиться правильно их
использовать.

##### Ссылки

Важнейшим свойством HTML являются ссылки, позволяющие связать текст или картинку с другими гипертекстовыми документами.
Текст, как правило, выделяется цветом и оформляется подчеркиванием, для чего используется тэг `<а>`, структура
которого следующая:

```html
<a href=”filename”>текст_ссылки</a>
```

Здесь `filename` — имя файла или адрес Internet, на который необходимо сослаться, а текст_ссылки — текст гипертекстовой
ссылки, который будет непосредственно показан в HTML доку менте. Например, гипертекстовая ссылка

```html

<а href=”my_work.html”>Views</a>
```

ссылается на документ `my_work.html`, образуя гипертекстовую ссылку в виде слова `Views`. Если документ, формирующий
ссылку, находится в другой папке, относящейся к web - сайту, то подобная ссылка называется относительной. Например:

```html

<а href=”photo/my_photo.html”>Moй фотоальбом</а>
```

ссылается на файл `my_photo.html`, расположенный в папке `photo`, вложенной в текущую, и образует ссылку в виде текста
`Мой фотоальбом`. Если есть необходимость сослаться на ресурс Internet, расположенный на удаленном сервере, или указать
в
ссылке полное имя файла и путь к файлу, то используют абсолютные ссылки. Структура такого тега аналогична, только он
формируется на основе полного пути к ресурсу в виде `протокол:/URL/путь`. Например:

```html

<а href=”https://www.google.com”>Поиск в интернет</а>
```

В HTML делят гиперссылки так же на два вида:

- Внешние гиперссылки перемещают пользователя нажавшего на них на другой HTML документ. Это те, которые мы рассмотрели
  выше.
- Внутренние гиперссылки (якоря) перемещают пользователя на предварительно созданную закладку в документе, в котором они
  определены.

```html
<!-- Создание гиперссылки на закладку -->
<a href="#bookmark"> Текст ссылки </a>
<!-- Создание закладки -->
<div id="bookmark"> Текст закладки.</div>
```

##### Изображение

В документах HTML могут использоваться изображения и графика, для чего используется тег `<img>`. Допускается
использование файлов в формате PNG, GIF или JPG/JPEG. Следующий пример демонстрирует вставку в документ JPG файла:

```html
<img src="pic.jpg" width=45 height=50 alt="Photo">
```

Здесь атрибут `src=` определяет **URL** адрес графического файла. В приведенном примере файл будет размещен в области
шириной 45 и высотой 50 пикселей соответственно. Если размеры, указанные атрибутами `height=` (высота) и `width=`
(ширина), не совпадают с размерами графического файла, то последний масштабируется. Рекомендуется для графических файлов
всегда задавать их размеры в таблицах стилей CSS вместо атрибутов `height` и `width`.

Атрибут `alt=` указывает, что именно подставить на место рисунка, если браузер не показывает графические файлы или
вследствие медленной скорости соединения файл еще не получен. Данный атрибут обязателен с точки зрения семантики и
валидатор будет выдавать ошибку.

Картинка может быть средством задания и управления выбором гиперссылок в HTML документе, для чего на тег `img` должна
указывать гиперссылка, определяемая тегом `а`. Например

```html

<а href="index.htm">
    <img src="logo.jpg" width="43" height="35" alt="На главную страницу">
    </a>
```

##### Списки

Язык HTML имеет возможности для создания различных списков и перечислений. Для их создания могут использоваться
теги `ul`
и `ol`, а элементы списка отмечаются тегом `li`, при этом допускаются вложенные списки любой глубины.
Рассмотрим следующий пример ненумерованного списка и использования тегов `ul` и `li`

```html

<ul>
    <li> красный</li>
    <li> оранжевый</li>
    <li> желтый</li>
    <li> зеленый</li>
    <li> голубой</li>
    <li> синий</li>
    <li> фиолетовый</li>
</ul>
```

Нумерованный список создают, используя теги `ol` и `li` Например список:

```html

<ol>
    <li>элемент первый</li>
    <li>элемент второй</li>
    <li>элемент третий</li>
</ol>
```

По умолчанию нумерация дается арабскими цифрами, начиная с единицы. Используя атрибуты тега `ol`, можно изменить стиль
оформления списка. Атрибут `type=` определяет стиль нумерации (буквы или цифры), при этом допускаются следующие его
значения:

- `type=A` - использовать большие латинские буквы;
- `type=a` - использовать маленькие буквы;
- `type=I` - использовать большие римские цифры;
- `type=i` - использовать маленькие римские цифры;
- `type=1` - использовать арабские цифры

Атрибут `start=` определяет начальное значение списка (десятичное число), например `start=5`.

И наконец, рассмотрим пример вложенного списка, в котором допускается использовать теги `ul`, `ol` и `li`

```html

<ul>
    <li>Первый раздел</li>
    <ul>
        <li>Первый подраздел первого раздела</li>
        <li>Второй подраздел первого раздела
            <ol type="a">
                <li>Первый список</li>
                <li>Второй список</li>
            </ol>
        </li>
        <li>Третий подраздел первого раздела</li>
    </ul>
    <li>Второй раздел</li>
</ul>
```

##### Комментарии

Тег добавляет комментарий в код документа. Текст комментария не отображается на странице. Разрешается внутрь комментария
добавлять другие теги, вложенные комментарии (когда один комментарий расположен внутри другого) недопустимы.

```html
<!-- текст комментария -->
```

С помощью комментариев Вы можете оставлять в коде пояснительные заметки.

- Комментарии полностью игнорируются браузером;
- Комментарии не отображаются при просмотре страницы.

- Комментарии могут использоваться при отладке кода, если Вы не уверены хотите ли видеть данный заголовок, абзац и т.д.
  в
  итоговой версии страницы Вы можете обернуть код в тэг `<!-- -->` на время принятия решения.

##### Спецсимволы HTML

Помимо тегов в языке HTML используется специальный управляющий символ `&` — амперсанд. Этот символ используется для
вывода
специальных символов и символов из расширенной кодовой таблицы, которые нельзя ввести с клавиатуры. Например, вывод
самого символа амперсанд `&` осуществляется посредством последовательности символов `&аmp;` для вывода угловых скобок
используются `&lt;` для `<` и `&gt;` для `>`, а, скажем, символ с номером `182` из кодовой таблицы, может быть задан
последовательностью `&#182;`.

Самый часто используемый спецсимвол - это неразрывный пробел (его мнемоника `&nbsp;`).

Данный символ используется для контролирования переноса строки (после данного символа автоматический перевод строки
невозможен) и для вставки в текст подряд идущих пробелов (по умолчанию если Вы вставите в текст 5 подряд идущих пробелов
браузер вырежет 4 и отобразит лишь один).

Мнемоники и коды часто используемых спецсимволов

| Символ | Описание                         | Мнемоника | Код      |
|--------|----------------------------------|-----------|----------|
|        | Пробел                           | `&nbsp;`  | `&#160;` |
| `<`    | Меньше чем                       | `&lt;`    | `&#60;`  |
| `>`    | Больше чем                       | `&gt;`    | `&#62;`  |
| ©      | Знак авторского права            | `&copy;`  | `&#169;` |
| ®      | Зарегистрированный товарный знак | `&reg;`   | `&#174;` |
| `&`    | Знак амперсанда                  | `&amp;`   | `&#38;`  | 

##### Семантические тэги

Благодаря использованию CSS Вы можете создавать страницы с хорошо понятной для пользователей визуальной структурой, но
будут ли эти страницы также понятны для поисковых систем или браузеров?

Например, как поисковый робот может отличить содержимое документа от навигационного меню если они размечены с помощью
одинаковых div элементов?

Для того, чтобы разрешить эту проблему в HTML5 были введены семантические тэги. С помощью семантических тэгов Вы можете
сделать страницы сайтов более понятными для поисковых систем и браузеров.

- `<footer>` Определяет футер.
- `<header>` Определяет заголовочный блок сайта.
- `<nav>` Определяет навигационное меню.

С помощью тэга `<section>` Вы можете группировать логически связанное содержимого в документе.

Если логически связанное содержимое является автономным (может использоваться в других документах независимо от
остального содержимого на странице) необходимо использовать вместо `<section>` тэг `<article>`.

Тэг `<aside>` используется для выделения элементов, которые не являются частью содержимого, но косвенно с ним связаны.
Данным тэгом могут выделяться: цитаты, дополнительная информация к статье, словарь с терминами, список ссылок и т.д.
Как уже говорилось выше с помощью тэга `<mark>` Вы можете выделить "важную" часть в тексте.

В журналах и газетах иллюстрации часто сопровождаются подписями. В HTML4 невозможно было создавать подписи не прибегая к
использованию CSS.

В HTML5 это проблема решена добавлением новых тэгов: `<figure>` и `<figcaption>`.

```html

<figure>
    <img src='foto-1387634.jpg' width='300' height='230'/>
    <figcaption>Мы с Таней на отдыхе, 'Черное море'</figcaption>
</figure>
```

##### Форма

Функциональность сайтов, предоставляющих пользователю возможность ввода данных и получения результатов их обработки,
обеспечивается использованием программ, работающих на стороне сервера — серверных приложений. Эти приложения
обрабатывают полученные от посетителя Web-сайта данные и выдают результат в виде обычной Web-страницы. Именно для них в
HTML предусмотрена возможность создания Web-форм и элементов управления — чтобы посетитель мог ввести данные, которые
потом обработает серверное приложение

Основная схема работы серверного приложения

1. Посетитель вводит в элементы управления, расположенные в Web-форме на Web-странице, нужные данные.
2. Введя данные, посетитель нажимает расположенную в той же Web-форме особую кнопку — кнопку отправки данных (Send, Ok,
   и т.д.).
3. Web-форма кодирует введенные в нее данные и отправляет их серверному приложению, расположенному по-указанному
   URL.
4. Web-сервер перехватывает отправленные данные, запускает серверное приложение и передает данные ему.
5. Серверное приложение обрабатывает полученные данные.
6. Серверное приложение формирует ответ (возможно, это Web-страница) с результатами обработки данных посетителя и
   передает ее Web-серверу.
7. Web-сервер получает сформированную серверным приложением ответ и отправляет ее посетителю.

Форма предназначена для обмена данными между пользователем и сервером. Область применения форм не ограничена отправкой
данных на сервер, с помощью клиентских скриптов можно получить доступ к любому элементу формы, изменять его и применять
по своему усмотрению.

Для создания интерактивных html документов используют заполняемые формы, определяемые тегом `form`. В одном html
документе может быть определено несколько форм для заполнения, но одновременно на сервер может быть отправлена только
одна форма.

По этой причине данные форм должны быть независимы друг от друга и вложенные теги `form` не допускаются. Формат
тега `form` следующий:

```html

<form action="url" method="GET/POST">
    ...
</form>
```

Здесь используются следующие атрибуты:

- `action=url` - URL адрес сервера запросов, куда будет отослано содержание формы после подтверждения, если это поле
  отсутствует, будет использован URL адрес текущего документа.
- `method=GET/POST` - HTTP метод, используемый для посылки содержания заполненной формы на сервер. Возможные варианты
  при этом следующие:
    - `GET` - это метод по умолчанию, который приводит к добавлению содержимого заполненной формы к URL;
    - `POST` - при использовании этого метода содержимое заполненной формы пересылается не как часть URL, а как
      содержимое
      тела запроса.
- `ENCTYPE=` задаёт тип кодирования содержимого заполненной формы. Этот атрибут действует только когда, используется
  метод **POST**.

Когда форма отправляется на сервер, управление данными передаётся программе, заданной атрибутом `action` тега `<form>`.
Предварительно браузер подготавливает информацию в виде пары `"имя=значение"`, где имя определяется атрибутом `name`
тега `<input>`, а значение введено пользователем или установлено в поле формы по умолчанию.

Внутрь контейнера `<form>` помещаются другие теги, при этом сама форма никак не отображается на веб-странице, видны
только
ее элементы и результаты вложенных тегов.

**Теги формы**

Внутри тега `form` могут находиться любые теги, кроме другого тега `form`. Для задания интерфейсных элементов
внутри `form`
используются теги `input`, `select`, `textarea` и другие. Давайте их рассмотрим.

Для того чтобы ввести информацию о пользователе (логин, пароль, дату рождения и т.д.) используют элемент ввода `<input>`
.
Его основной атрибут – `type` – определяет, что мы будем вводить и как.

Тег `input` используется для задания простого элемента ввода, при этом могут быть использованы атрибуты:

- `accept`– устанавливает фильтр на типы файлов, которые вы можете отправить через поле загрузки файлов;
- `alt` – альтернативный текст для кнопки с изображением;
- `autocomplete` –включает или отключает автозаполнение, соответственно принимает значения `on` и `off`;
- `checked` – предварительно активированный переключатель или флажок;
- `disabled` – блокирует доступ и изменение элемента;
- `list` – указывает на список вариантов, которые можно выбирать при вводе текста;
- `max` – максимально допустимое значение для ввода числа или даты;
- `maxlength` –максимально допустимое количество символов разрешенных в тексте;
- `min` - минимально допустимое значение для ввода числа или даты;
- `multiple` – позволяет загрузить несколько файлов одновременно;
- `name` – задает имя поля, предназначено для того, чтобы обработчик формы мог его идентифицировать;
- `pattern` – устанавливает шаблон ввода;
- `placeholder` – выводит подсказывающий текст;
- `readonly` – устанавливает, что поле не может изменяться пользователем;
- `required` – отмечает, что поле является обязательным для заполнения;
- `size` –задает ширину текстового поля;
- `step` – задает шаг приращения для числовых полей;
- `tabindex` – определяет порядок перехода между элементами с помощью клавиши **Tab**;
- `type` – сообщает браузеру, к какому типу относится элемент формы.
- `value` – определяет значение элемента.

Значения предпоследнего атрибута `type` в списке очень обширны и важны, поскольку задают поведение при вводе в `input`

| Значение         | Описание                                                                                     |
|------------------|----------------------------------------------------------------------------------------------|
| `button`         | Кнопка                                                                                       |
| `checkbox`       | Флажки. Позволяют выбрать более одного варианта из предложенных.                             |
| `file`           | Поле для ввода имени файла, который пересылается на сервер.                                  |
| `hidden`         | Скрытое поле. Оно никак не отображается на веб-странице.                                     |
| `image`          | Поле с изображением. При нажатии на рисунок данные формы отправляются на сервер.             |
| `password`       | Обычное текстовое поле, но отличается от него тем, что все символы показываются звездочками. |
| `radio`          | Переключатели. Используются, когда следует выбрать один вариант из нескольких предложенных.  |
| `reset`          | Кнопка для возвращения данных формы в первоначальное значение.                               |
| `submit`         | Кнопка для отправки данных формы на сервер.                                                  |
| `text`           | Текстовое поле. Предназначено для ввода символов с помощью клавиатуры.                       |
| `color`          | Виджет для выбора цвета.                                                                     |
| `date`           | Поле для выбора календарной даты.                                                            |
| `datetime`       | Указание даты и времени.                                                                     |
| `datetime-local` | Указание местной даты и времени.                                                             |
| `email`          | Для адресов электронной почты.                                                               |
| `number`         | Поле ввода чисел. Ввод символов, не являющихся цифрами, приведет к выводу предупреждения.    |
| `range`          | Ползунок для выбора чисел в указанном диапазоне.                                             |
| `search`         | Поле для поиска.                                                                             |
| `tel`            | Поле для телефонных номеров.                                                                 |
| `time`           | Поле для времени.                                                                            |
| `url`            | Поле для веб-адресов.                                                                        |

Очень часто мы сталкиваемся с необходимостью выбора. Например, мы выбираем, согласны ли с лицензионным соглашением, мы
выбираем какие странички отображать в меню соц. сети, приложения…

Когда надо выбрать несколько элементов из многих, используют `checkbox` – поле с
квадратиком, куда устанавливается галочка. Создается такое поле так

```html
<input id="checkbox1" type="checkbox" value="Английский"/> Английский <br/>
```

`value` – значение, которое Вы выбрали. Используется для обработки в скриптах. Рядом с полем пишется то слово, которое
соответствует элементу выбора, и мы хотим отобразить на странице в браузере.

Иногда мы можем выбирать только один элемент из списка предложенных альтернатив. Например, мы выбираем пол:
мужской/женский. Такой выбор нам помогут организовать радиокнопки. Создаются они так:

```html
<input type="radio" name="gender" value="мужской"/> мужской
<input type="radio" name="gender" value="женский"/> женский
```

Обратите внимание, что имена `name` – одинаковые. Это обеспечивает то, что вы сможете выбрать (одновременно) только один
из элементов.

Иногда очень удобно задавать альтернативы в виде выпадающего списка. На некоторых сайтах так организован выбор страны,
вуза, возраста. Задание перечня альтернатив удобно для обработки, так как пользователь правильно введёт данные.
Использование выпадающего списка значительно экономит место на форме.

Тег `select` предназначен для создания списков в форме, при этом внутри разрешена только последовательность
тегов `option`,
за каждым из которых следует некоторое количество простого текста.

Атрибуты тега `select` следующие:

- `name=идентификатор` - символьное имя для элемента `select`, по которому он идентифицируется;
- `size=n` - если значение равно 1 или если этот атрибут опущен, то элемент `select` будет представлен как выпадающее
  меню,
  если `size=2` или более, то элемент будет представлен как окно выбора, а значение будет определять, сколько элементов
  списка будут видны;
- `multiple` - если этот атрибут присутствует, то допускается множественный выбор из списка.

Создать список можно так:

```html
<select id="select1">
    <option>Элемент списка</option>
    ...
</select>
```

где `select` – сам список, `option` – элемент списка.

Можно так же организовать выбор из заданного списка: `datalist`. Это называется альтернатива и ее можно задавать с
помощью списка вариантов. Это выглядит так:
Любимое блюдо

```html
<input type="text" name="team" id="favorite_dish" list="dish_list">
<datalist id="dish_list">
    <option>Борщ</option>
    <option>Суп</option>
    <option>Харчо</option>
    <option>Окрошка</option>
</datalist>
```

Обратите внимание на то, что атрибут `list` элемента `input` и атрибут `id` элемента `<datalist>` содержат одинаковое
значение
`dish_list`. Это их связывает.

Тег `button` создает на веб-странице кнопки и по своему действию напоминает результат, получаемый с помощью
тега `<input>` (с атрибутом `type="button | reset | submit"`). В отличие от этого тега, `<button>` предлагает
расширенные возможности по созданию кнопок. Например, на подобной кнопке можно размещать любые элементы HTML, в том
числе изображения. Используя стили можно определить вид кнопки путём изменения шрифта, цвета фона, размеров и других
параметров.

Теоретически, тег `<button>` должен располагаться внутри формы, устанавливаемой элементом `<form>`. Тем не менее
браузеры не выводят сообщение об ошибке и корректно работают с тегом `<button>`, если он встречается самостоятельно.
Однако, если необходимо результат нажатия на кнопку отправить на сервер, помещать `<button>` в контейнер `<form>`
обязательно.

И, наконец, тег `textarea` может быть использован для расположения многострокового поля ввода с необязательным 
содержимым в форме. 

Атрибуты тега `textarea` следующие:
- `name=` - символьное имя поля ввода;
- `rows=` - число строк в поле ввода, то есть высота поля;
- `cols=` - число столбцов в поле ввода, то есть ширина поля.

Объект `textarea` имеет полосы прокрутки, так что может быть введено любое количество текста. Содержание по умолчанию
должно быть строгим **ASCII** текстом, при этом символы перевода строки воспринимаются.

Пример несложной формы

```html
<form method="POST" name="student" action='/students'>
	<label for="firstname"> Введите Ваше имя 
		</br> 
		<input  type= "text" id ="firstname" name="firstname"  size="45"/> 
	</label>
	</br></br>
	<input type="radio" checked name="job"/> <span>Учащийся ВУЗа</span>
	</br> 
	<input type="radio"  name="job" /> <span>Другое</span> 
	</br></br>
	<button type="submit"> Submit </button> 
	<button type= "reset"> Reset </button> 
</form>
```

> Примечание: `</br>` тег перевода строки

#### Верстка

### Занятие m07_02 (19.08.2022) 

